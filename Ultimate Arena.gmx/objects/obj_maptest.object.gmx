<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>mapSurf = -1;

px = 512;
py = 512;

hflip = 1;
vflip = 1;
rot = 90;
refresh = 10;

colSurf = surface_create(512,512);
heightSurf = surface_create(512,512);

surface_set_target(colSurf);
draw_clear_alpha(c_black,1);
draw_sprite_ext(spr_map,0,256,256,hflip,vflip,rot,c_white,1);
surface_reset_target();

surface_set_target(heightSurf);
draw_clear_alpha(c_black,1);
draw_sprite_ext(spr_map,1,256,256,-1,1,0,c_white,1);
surface_reset_target();

hBuff = noone;
xDivisions = 512;
yDivisions = 512;

terrainHeight = 128;

vertex_format_begin();
vertex_format_add_position_3d();
vertex_format_add_textcoord();
vertFormat = vertex_format_end();

texture = surface_get_texture(colSurf);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>
if(keyboard_check_pressed(vk_space))
{
    rot += 90;
    refresh = 2;
}

if(refresh &gt; 0)
{
    surface_set_target(colSurf);
    draw_clear_alpha(c_black,1);
    draw_sprite_ext(spr_map,0,256,256,hflip,vflip,rot,c_white,1);
    surface_reset_target();
    texture = surface_get_texture(colSurf);
    refresh--;
}



</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(hBuff == noone)
{
    mSize = 512;
    
    
    var size = (4 * mSize * mSize) + 8;
    hBuff = buffer_create(size, buffer_fixed, 1);
    
    buffer_write(hBuff,buffer_f32,mSize);
    buffer_write(hBuff,buffer_f32,mSize);
    buffer_get_surface(hBuff, heightSurf,0,8,0);
    
    vertexBuffer = vertex_create_buffer();
    vertex_begin(vertexBuffer,vertFormat);
    for(var i = 0;i &lt; xDivisions - 1;i++)
    {
        for(var c = 0;c &lt; yDivisions - 1;c++)
        {
            var p1x = floor((i * mSize) / xDivisions);
            var p1y = floor((c * mSize) / yDivisions);
            
            var p2x = floor(((i + 1) * mSize) / xDivisions);
            var p2y = floor(((c + 1) * mSize) / yDivisions);
            
            var pz1 = buffer_get_height(hBuff,p1x,p1y) * terrainHeight / 255;
            var pz2 = buffer_get_height(hBuff,p2x,p1y) * terrainHeight / 255;
            var pz3 = buffer_get_height(hBuff,p1x,p2y) * terrainHeight / 255;
            var pz4 = buffer_get_height(hBuff,p2x,p2y) * terrainHeight / 255;
            
            var tx1 = (i / xDivisions);
            var ty1 = (c / yDivisions);
            var tx2 = ((i+1) / xDivisions);
            var ty2 = ((c+1) / yDivisions);
            
            //tri 1
            vertex_position_3d(vertexBuffer,i,c,pz1);
            vertex_texcoord(vertexBuffer,tx1,ty1);
            vertex_position_3d(vertexBuffer,i,c+1,pz3);
            vertex_texcoord(vertexBuffer,tx1,ty2);
            vertex_position_3d(vertexBuffer,i+1,c,pz2);
            vertex_texcoord(vertexBuffer,tx2,ty1);
            
            //tri 2
            vertex_position_3d(vertexBuffer,i+1,c,pz2);
            vertex_texcoord(vertexBuffer,tx2,ty1);
            vertex_position_3d(vertexBuffer,i,c+1,pz3);
            vertex_texcoord(vertexBuffer,tx1,ty2);
            vertex_position_3d(vertexBuffer,i+1,c+1,pz4);
            vertex_texcoord(vertexBuffer,tx2,ty2);
            
        }
    }
    vertex_end(vertexBuffer);
    vertex_freeze(vertexBuffer);
    instance_create(0,0,obj_mapcamera);
    
}
else
{
    //vertex_submit(vertexBuffer, pr_trianglelist, texture);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
