<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>mapSurf = -1;
mapWidth = 512;
mapHeight = 512;

px = 512;
py = 512;

colSurf = surface_create(1024,1024);
heightSurf = surface_create(1024,1024);

phi = 0;
ybuffer[mapWidth] = 0;

surface_set_target(colSurf);
draw_clear_alpha(c_black,1);
draw_sprite(spr_map,0,0,0);
surface_reset_target();

surface_set_target(heightSurf);
draw_clear_alpha(c_black,1);
draw_sprite(spr_map,1,0,0);
surface_reset_target();

//=== Determine Width and Height ==//
var ww = 1024
var hh = 1024

//=== Surface to Buffer ===//
colBuff=buffer_create(4 * ww * hh, buffer_fixed, 1);
buffer_get_surface(colBuff, colSurf, 0, 0, 0);
surface_free(colSurf);// we don't need the surface anymore

heiBuff=buffer_create(4 * ww * hh, buffer_fixed, 1);
buffer_get_surface(heiBuff, heightSurf, 0, 0, 0);
surface_free(heightSurf);// we don't need the surface anymore


/*
    
// === Cleanup ===//
buffer_delete(colBuff);       
buffer_delete(heiBuff);     
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>var renW = 256;
var renH = 256;


if(!surface_exists(mapSurf))
    mapSurf = surface_create(renW,renH);

var height = 150;
var horizon = 40;
var scale_height = 120;
var distance = 600;

var plx = 0;
var prx = 0;
var ply = 0;
var pry = 0;

var sinphi = sin(phi);
var cosphi = cos(phi);
if(keyboard_check(ord("W")))
{
    z = 1;
    plx = (-cosphi*z - sinphi*z) + px;
    ply = ( sinphi*z - cosphi*z) + py;
    prx = ( cosphi*z - sinphi*z) + px;
    pry = (-sinphi*z - cosphi*z) + py;
    px = (plx+prx)/2;
    py = (ply+pry)/2;
}
    

if(keyboard_check(ord("E")))
    phi+=.1;
if(keyboard_check(ord("Q")))
    phi-=.1;

for(var i = 0;i &lt; renW;i++)
    ybuffer[i] = renW;

surface_set_target(mapSurf);
draw_clear_alpha(make_color_rgb(77,179,240),1);
var sinphi = sin(phi);
var cosphi = cos(phi);

var z = 40;
var dz = .1;
var cl = 0;
var cycles = 0;
while(cycles &lt; 75)
{

    plx = (-cosphi*z - sinphi*z) + px;
    ply = ( sinphi*z - cosphi*z) + py;
    prx = ( cosphi*z - sinphi*z) + px;
    pry = (-sinphi*z - cosphi*z) + py;
    
    var dx = (prx - plx) / renW;
    var dy = (pry - ply) / renW;
    //Render time
    for(var i = 0;i &lt; renW;i++)
    {
        if(plx &lt; 0 || plx &gt; 1023 || ply &lt; 0 || ply &gt; 1023)
        {
            plx += dx;
            ply += dy;
            continue;
        }
        rx = round(plx);
        ry = round(ply);
            
        //var hm = map_getheight(plx,ply);
        
        var pixel = buffer_peek(heiBuff, 4 * (rx + ry * 1024), buffer_u32)    // extracts info in ABGR Format
        var hm = pixel &amp; $ff; 
        
        height_on_screen = (height - hm) / z * scale_height + horizon;
        
        if(height_on_screen &lt; ybuffer[i])
        {  
            //var cm = map_getcolor(plx,ply);
            pixel = buffer_peek(colBuff, 4 * (rx + ry * 1024), buffer_u32)    // extracts info in ABGR Format
            cm = make_color_rgb(pixel &amp; $ff, (pixel &gt;&gt; 8) &amp; $ff, (pixel &gt;&gt; 16) &amp; $ff);
            
            draw_set_color(merge_color(cm,make_color_rgb(77,179,240),min(cl,.98))); 
            
            draw_line(i, height_on_screen, i, ybuffer[i])
            ybuffer[i] = height_on_screen;
        }
          /*  
        if(cycles &gt; 60)
        {
            i+=2;
            plx += dx*3;
            ply += dy*3;
        }
        else if(cycles &gt; 40)
        {
            i+=1;
            plx += dx*2;
            ply += dy*2;
        }
        else*/
        {
            plx += dx;
            ply += dy;
        }

        
        
    }
    
    z += dz;
    dz += .12;
    cl += .005;
    cycles++;
    if(cycles &gt; 50)
        dz += .23;
}
//show_debug_message(string(cycles));
draw_set_color(c_black);
draw_set_valign(fa_top);
draw_set_halign(fa_left);
draw_text(10,10,fps);
surface_reset_target();

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>draw_surface_ext(mapSurf,50,50,2,2,0,c_white,1);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
